[lambda]: img/lambda.png

## <a name="modules"></a> Modules

Elixir uses the concept of modules for grouping several functions together. Functions, other than anonymous functions, cannot be declared outside the scope of a module. We introduce the modules here very briefly and return to them when we start building something more complex. 

```elixir
iex> defmodule Math do 
...>  def square(a) do
...>    a * a
...>  end
...>end

iex> Math.square(2)
4
```

A module can be declared using the `iex` interpreter, or by saving the contents of the module to a file with the `.ex` extension by convention. Modules declared in separate files should be compiled with the `elixirc` compiler

``` elixir
defmodule <module_name> do
  # Module body
end
```

The module definition follows the format `defmodule` module name `do` ... module body ... `end`. Functions within a module are defined with the `def` macro and private functions visible only within the lexical scope of the module use the `defp` macro. 

``` elixir
def function_name(param_a, param_b) do
  # Function body
end
```

Both public and private functions follow the structure `def` fn_name(params..) `do` ... function body ... `end`

```elixir
def square(a) do
  a * a
end
```
<div class="key-concept">
<a name="implicit_return_values"></a> <span>Implicit return values</span>
![Key concept][lambda] <p>It is also worth noticing, that the function `square/1` does not have an explicit `return` statement or similar, like imperative languages such as Java or C tend to use. </p>

<p>This is a common feature in functional languages. The function body is an expression, and the last evaluated value in the function body is treated as the function's return value.</p>
</div>

```elixir
defmodule Math do
  def square(a) do
    a * a
  end
end
```

Create a new file called `math.ex` and save the contents above inside the file.

```bash
$ elixirc math.ex
```

When the module is defined in it's own file, the module can be compiled with the `elixirc` command followed by the filename. The bytecode resulting from the compilation of our example can be found from the file `Elixir.Math.beam` 

```elixir
iex> Math.square(2)
4
```

When executing the `iex` REPL in the same directory the compiled file is stored in, the module is automatically available for the Elixir interpreter. 

## <a name="functions"></a> Functions
### <a name="first_class_citizens"></a>  Functions as first-class citizens
<div class="key-concept">
 ![Key concept][lambda]<span>Functions are first-class citizens</span>
 <p>Extensive use and composition of short, single purpose functions is one of the distinguishing properties of functional programming. Functions are first class citizens in functional programming: functions are acceptable parameters for functions, functions can be anonymous or named, assigned to variables, stored in data structures and functions can return functions as their return values.</p>

<p>In other words, function is a value with the type function, which when evaluated, reduces to the return value generated by the expression captured by the function. </p>
</div>

```elixir
defmodule Temperature do
  def fahrenheit_to_celsius(t) do
    (t - 32) * 5/9
  end

  def celsius_to_fahrenheit(t) do
    t * 9/5 + 32
  end

  def celsius_to_kelvin(t) do
     273.15 + t
  end

  def kelvin_to_celsius(t) do
    t + 273.15
  end

  def kelvin_to_fahrenheit(t) do
    celsius_to_fahrenheit(kelvin_to_celsius(t))
  end

  def fahrenheit_to_kelvin(t) do
    celsius_to_kelvin(fahrenheit_to_celsius(t))
  end
end
```

The above is an example of the module `Temperature` which consists of conversion functions between temperatures reported in celsius, kelvin and fahrenheit. The functions do not have an explicit return statement, instead the functions return the value the expression representing the function body evaluates to. In this case, the expressions of the functions evaluate to the result of the calculation declared in the function body. 

```elixir
defmodule PersonOps do
  def print_age(p) do
    IO.puts("The person's age is #{p.age}")
  end

  def print_name(p) do 
    name = p.first_name <> " " <> p.last_name
    IO.puts("The person's name is #{name}")
  end
end
```

Let's declare some operations for a person represented by the map type. The person has three properties, `first_name`, `last_name` and `age`.

```elixir
iex> person = %{first_name: "Esko", last_name: "Erikoinen", age: 42}
%{age: 42, first_name: "Esko", last_name: "Erikoinen"}

iex> PersonOps.print_age(person)
The person's age is 42
:ok

iex> PersonOps.print_name(person)
The person's name is Esko Erikoinen
:ok
```
You'll notice that the functions perform the actions you expected. A careful reader makes an additional note: now that the `IO.puts\1` is the last value of the expression declared in the function body, in addition to the `:stdout` output the function returns the atom `:ok` indicating a succesful I/O operation.

Repeat after me: everything is an expression, and every expression evaluates to a value.

In Elixir everything is an expression, as in everything has an identifiable value.

## <a name="recursion"></a> Recursion

<div class="key-concept">
![Key concept][lambda]<span>Recursion is looping</span>
<p>Recursion plays an important part in functional programming. Recursion is equivalent to looping, so expect to see no `for` or `while` loops when looking at functionally written code, but expect to see lots and lots of recursion.</p>

<p>Recursive function is a function that calculates it's final value by repeated application of the function - in other words - function calling itself over and over again.</p>

<p>Recursion and thinking recursively might feel a little strange for those used to the imperative programming paradigm. In the end, recursion is no different from using for or while loops.</p>
</div>

```java
static int factorial(int n) {
  if(n < 2) {
    return n;
  }
  int res = 1;
  while(n > 1) {
    res = n * res;
    n--;
  }
  return res;
}

```

The above is an example of an imperative approach to the commonly implemented factorial function. The function first checks if the input parameter is valid for calculating factorial and then loops the following: multiply the integer `res` with the input number `n` and decrement `n` while `n` has a value over `1`.

```elixir
defmodule MathEx do
  def fact(n) do
    if(n < 2) do
      n
    else
      n * fact(n-1)
    end
  end
end
```

The factorial function can be easily re-written to use a recursive approach. The principle of operation is the same, if `n < 2`, return `n`. Otherwise  multiply `n` with the result of the function `fact(n-1)`.

```elixir
iex> MathEx.fact(5)
120

# What happens in the function is:

iex> MathEx.fact(5)
    --> 5 * fact(4)
      --> 4 * fact(3)
        --> 3 * fact(2)
          --> 2 * fact(1)
            --> 1 # Recursion-terminating return value of fact(1)
120
```

It is always important to have a terminating condition for recursion (`n < 2`) otherwise the recursive function will call itself indefinitely, eventually resulting in a stack overflow.

```java
int[] array = {1,2,3,4,5};

static int[] squareArray(int[] array) {  
  int[] result = new int[array.length];

  for(int i = 0 ; i < ; array.length ; ++i) {
    result[i] = array[i] * array[i];
  }

  return result;
}

int[] result = squareArray(array); // Yields an array of {1, 4, 9, 16, 25};

```

The Java code above represents a simple algorithm filling a result array with the squared values of the input array. Let's make a recursive rewrite of the function:

```elixir
defmodule ArrayOps do
  def square_list([]) do
    []
  end
  def square_list([head|tail]) do
    [head*head | square_list(tail)]
  end
end

iex> ArrayOps.square_list [1,2,3,4,5]
[1, 4, 9, 16, 25]
```

Here we already play with a new concept called pattern matching, which we will discuss in more detail in a later chapter.

We defined a module `ArrayOps` with a two variants of the function `square_list/1`. The first variant accepts a pattern matching an empty list. The second variant accepts a pattern for a non-empty list (remember from the lists-section, that the function `hd\1` raises an exception for an empty list).

The second function multiplies the head of the list with itself, and prepends the result to the result produced by a recursive call to the same function `square_list/1`. The recursive call can now match against either of the functions by the same name.

The pattern matching is also used in the function parameters with the syntax `[head|tail]` to extract the head element from the tail of the list, as introduced in the lists-chapter earlier.

## <a name="tail_call_optimization"></a> Tail call optimization
<div class="key-concept">
![Key concept][lambda]<span>Tail call optimization</span>
<p>The function we defined does not come without problems. The Elixir compiler supports a feature called *tail call optimization* (or tail call elimination) for recursive functions. Tail call optimization refers to the elimination of the actual recursive call in favor of transforming the recursive calls in to a loop.</p>

<p>The optimization is a significant performance improvement over recursion. After the transformation the virtual machine does not need to allocate a new call stack to the successive recursive function calls, but can instead reuse the original stack created during the initial function call.</p>

<p>The condition for the tail call optimization to be applied is to formulate the recursive call so that the final, recursion-terminating call does not need any values from the previous function calls.</p>
</div>

```elixir
defmodule ArrayOps do
  def square_list(list) do
    do_squaring([], list)
  end

  defp do_squaring(acc, []) do 
    acc
  end

  defp do_squaring(acc, [head|tail]) do
    do_squaring([head*head | acc], tail)
end

iex> ArrayOps.square_list [1,2,3,4,5]
[1, 4, 9, 16, 25]
```

The rewritten `square_list\1` uses a helper function to enable the elimination of the call stack creation. Creating a private helper function `do_squaring/2` within the module allows for the original call syntax for the users' of the function.

`do_squaring/2` takes two parameters, an accumulator list that holds the squared values and the list with the values to square. The function iterates over the list element-by-element, and finally when the list runs out of elements, the `do_squaring/2` returns the accumulated value.

<div name="exercises_week1" class="exercise-container">
    <span class="group-name">Week1 exercises</span>
    <p>The exercises for this set can be previewed in exercise_drafts/week1.ex</p>
</div>

## Guards in functions

```elixir
defmodule MathEx do
  def fact(n) when (is_number(n) and n > -1) do
    if(n < 2) do
      n
    else
      n * fact(n-1)
    end
  end
end

iex> MathEx.fact("a")
** (FunctionClauseError) no function clause matching in MathEx.fact/1
    iex:75: MathEx.fact("a")

```

The function definitions can also be decorated with guards in order to allow the function to yield safe and predictable results. The factorial function does not work for numbers less than zero so we decorate the function definition with a guard with the `when <cond>` just before the block initiated by the `do` keyword. Our guard makes sure that the function receives a number and the function is of valid magnitude.

**TODO** Write a larger block about guards
 
## Functions as function parameters

**TODO** Write a block about the use of functions as parameters.

## <a name="lambda_functions"></a> λ (lambda) functions 
<div class="key-concept">
![Key concept][lambda]<span>Anonymous functions</span>
<p>The functional programming paradigm has its roots in lambda calculus. Functional language implementations support declaring lambda functions, often with a very efficient syntax. Lambda functions are also called anonymous functions, as they do not have a name associated with them most of the time.</p>

<p>The common use case for lambda functions is as parameters to functions accepting functions. Lambda functions are often treated as throwaway functions to complement the functionality of high order functions, which we will discuss in the next chapter.</p>
</div>

```elixir
iex> mult = fn(a,b) -> a * b end
#Function<12.54118792/2 in :erl_eval.expr/5>
iex> is_function(mult)
true
iex> mult.(3, 5)
15
```

On the first line we match an anonymous function accepting two parameters to a variable. The function just performs a multiplication for the arguments. 

The function is called by applying a the parameters `(3,5)` to the variable associated with the function. Notice that the arguments are separated from the variable by a dot `.` -  which is a requirement for calling anonymous functions in the case they get assigned to a variable.

Unlike regular functions, anonymous functions can be declared outside a module.

```elixir
iex> foo = "bar"
"bar"
iex> (fn -> foo = "quux" end).()
"quux"
iex>
"bar"
```

Lambda functions are closures, and such they have a private scope that only the anonymous function can access. Any variable declared within the scope of an anonymous function does not affect the higher level environment.

Like any other function or expression, the lambda function evaluates to the value returned by that expression.